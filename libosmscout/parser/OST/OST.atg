#include <iostream>

#include <osmscout/TypeConfig.h>
#include <osmscout/Util.h>

COMPILER OST

void HandleTag(const std::string& idValue,
               const std::string& nameValue)
{
  TagId        id;
  std::string  name(nameValue);

  if (!StringToNumber(idValue,id)) {
    SemErr("Cannot parse tag id");
    return;
  }

  if (config.GetTagId(nameValue.c_str())!=tagIgnore) {
    return;
  }

  if (id>=tagPrivateBase) {
    SemErr("Illegal tag id");
    //std::cerr << "Tag '" << value << "' has id in illegal range (must be <" << tagPrivateBase << ")!" << std::endl;
    return;
  }

  TagInfo tagInfo(name,id);

  config.AddTagInfo(tagInfo);
}

std::string Destring(const char* str)
{
  std::string result(str);

  if (result.length()>=2 &&
      result[0]=='"' &&
      result[result.length()-1]=='"') {
    result=result.substr(1,result.length()-2);
  }

  return result;
}

CHARACTERS
  letter     = 'a'..'z' + 'A'..'Z'.
  digit      = '0'..'9'.
  eol        = '\n'.
  stringchar = ANY - '"'.
  quotchar   = ANY.

TOKENS
  ident      = letter {letter | '_'}.
  number     = digit {digit}.
  string     = '"' {stringchar | '\\' quotchar} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\t' + '\r' + '\n'

PRODUCTIONS
  OST         = SYNC "OST" [TAGS] [TYPES] "END".
  TAGS        = SYNC "TAGS" TAG {TAG}.
  TAG         = (.
                  std::string  idValue;
                  std::string  nameValue;
                .)
                SYNC "TAG"
                "ID" number (. idValue=Destring(t->val); .)
                "VALUE" string (. nameValue=Destring(t->val); .)
                (.
                  if (!errors->hasErrors) {
                    HandleTag(idValue,nameValue);
                  }
                .).
  TYPES       = SYNC "TYPES" TYPE {TYPE}.
  TYPE        = (.
                  std::string idValue;
                  std::string nameValue;
                  std::string valueValue;
                  TypeId      id=0;
                  TypeInfo    typeInfo;
                .)
                SYNC "TYPE"
                "ID" number
                (.
                  idValue=t->val;

                  if (!StringToNumber(idValue.c_str(),id)) {
                    SemErr("Cannot parse type id");
                    //std::cerr << "Cannot parse id: '" << idValue << "'" << std::endl;
                  }

                  if (id>=typePrivateBase) {
                    SemErr("Illegal tag value");
                    //std::cerr << "Type '" << nameValue << "/" << valueValue << "' has id in illegal range (must be <" << typePrivateBase << ")!" << std::endl;
                  }
                .)
                "WHERE" string (. nameValue=Destring(t->val); .) "==" string (. valueValue=Destring(t->val); .)
                (.
                  TagId tag=config.GetTagId(nameValue.c_str());

                  if (tag==tagIgnore) {
                    std::string e;

                    e="Type with tag '"+nameValue+"/"+valueValue+"' has no corresponding tag definition, skipping!";

                    SemErr(e.c_str());
                  }
                  else {
                    typeInfo.SetType(id,tag,valueValue);
                  }
                .)

                TYPEKINDS<typeInfo>
                [TYPEOPTIONS<typeInfo>]
                (.
                  if (!errors->hasErrors &&
                      typeInfo.IsValid()) {
                    config.AddTypeInfo(typeInfo);
                  }
                .)
                .
  /*
  CONDITIONS  = ANDCOND { "OR" ANDCOND} .
  ANDCOND     = BOOLCOND { "AND" BOOLCOND}.
  BOOLCOND    = string BOOLOP string.
  BOOLOP      = "==".*/

  TYPEKINDS<TypeInfo& typeInfo>
              = "CAN" "BE" TYPEKIND<typeInfo> {TYPEKIND<typeInfo>}.
  TYPEKIND<TypeInfo& typeInfo>
              =  "NODE"      (. typeInfo.CanBeNode(true); .)
               | "WAY"       (. typeInfo.CanBeWay(true); .)
               | "AREA"      (. typeInfo.CanBeArea(true); .)
               | "RELATION"  (. typeInfo.CanBeRelation(true); .)
               .

  TYPEOPTIONS<TypeInfo& typeInfo>
              = "OPTIONS" TYPEOPTION<typeInfo> { TYPEOPTION<typeInfo>}.
  TYPEOPTION<TypeInfo& typeInfo>
              =  "ROUTE" (. typeInfo.CanBeRoute(true); .)
               | "INDEX" (. typeInfo.CanBeIndexed(true); .)
               .

END OST.

