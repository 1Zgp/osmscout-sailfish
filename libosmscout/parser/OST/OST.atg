#include <osmscout/TypeConfig.h>

COMPILER OST

std::string Destring(const char* str)
{
  std::string result(str);

  if (result.length()>=2 &&
      result[0]=='"' &&
      result[result.length()-1]=='"') {
    result=result.substr(1,result.length()-2);
  }

  return result;
}

CHARACTERS
  letter     = 'a'..'z' + 'A'..'Z'.
  digit      = '0'..'9'.
  eol        = '\n'.
  stringchar = ANY - '"'.
  quotchar   = ANY.

TOKENS
  ident      = letter {letter | digit | '_'}.
  number     = digit {digit}.
  string     = '"' {stringchar | '\\' quotchar} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\t' + '\r' + '\n'

PRODUCTIONS
  OST         = SYNC "OST" [TYPES] [TAGS] "END".
  TYPES       = SYNC "TYPES" TYPE {TYPE}.
  TYPE        = (.
                  std::string   name;
                  TagCondition  *condition=NULL;
                  TypeInfo      typeInfo;
                  unsigned char types;
                .)
                SYNC "TYPE"
                IDENT<name>                    (. typeInfo.SetType(name); .)

                "="
                TYPEKINDS<types>
                "(" CONDITION<condition> ")"   (. typeInfo.AddCondition(types,condition); .)

                {
                  "OR"
                  TYPEKINDS<types>
                  "(" CONDITION<condition> ")" (. typeInfo.AddCondition(types,condition); .)
                }

                [
                  "OPTIONS"
                  TYPEOPTIONS<typeInfo>
                ]

                (.
                  config.AddTypeInfo(typeInfo);
                .)
                .
  TAGS        = SYNC "TAGS" TAG {TAG}.
  TAG         = SYNC "TAG"
                string
                (.
                   std::string tagName=Destring(t->val);

                   if (tagName.empty()) {
                     std::string e="Empty tags are not allowed";

                     SemErr(e.c_str());
                   }
                   else {
                     config.RegisterTagForExternalUse(tagName);
                   }
                .)
                .

  CONDITION<TagCondition*& condition>
              = (.
                  std::list<TagCondition*> conditions;
                  TagCondition             *subCond;
                .)
                ANDCOND<subCond>   (. conditions.push_back(subCond); .)
                {
                  "OR"
                  ANDCOND<subCond> (. conditions.push_back(subCond); .)
                }
                (.
                  if (conditions.size()==1) {
                    condition=conditions.front();
                  }
                  else {
                    TagBoolCondition *orCondition=new TagBoolCondition(TagBoolCondition::boolOr);

                    for (std::list<TagCondition*>::const_iterator c=conditions.begin();
                         c!=conditions.end();
                         ++c) {
                      orCondition->AddCondition(*c);
                    }

                    condition=orCondition;
                  }
                .)
                .
  ANDCOND<TagCondition*& condition>
              = (.
                  std::list<TagCondition*> conditions;
                  TagCondition             *subCond;
                .)
                BOOLCOND<subCond>     (. conditions.push_back(subCond); .)
                {
                  "AND"
                  BOOLCOND<subCond>   (. conditions.push_back(subCond); .)
                }
                (.
                  if (conditions.size()==1) {
                    condition=conditions.front();
                  }
                  else {
                    TagBoolCondition *andCondition=new TagBoolCondition(TagBoolCondition::boolAnd);

                    for (std::list<TagCondition*>::const_iterator c=conditions.begin();
                         c!=conditions.end();
                         ++c) {
                      andCondition->AddCondition(*c);
                    }

                    condition=andCondition;
                  }
                .)
                .
  BOOLCOND<TagCondition*& condition>
              =   BINARYCOND<condition>
                | EXISTSCOND<condition>
                | "(" CONDITION<condition> ")"
                | "!" BOOLCOND<condition> (. condition=new TagNotCondition(condition); .)
                .

  BINARYCOND<TagCondition*& condition>
              = (.
                  std::string nameValue;
                .)
                string (. nameValue=Destring(t->val); .)
                (
                  EQUALSCOND<nameValue,condition>
                | NOTEQUALSCOND<nameValue,condition>
                | ISINCOND<nameValue,condition>
                )
                .

  EQUALSCOND<const std::string& tagName,TagCondition*& condition>
              = (.
                  std::string valueValue;
                .)
                "=="
                string (. valueValue=Destring(t->val); .)
                (.
                  TagId tagId=config.RegisterTagForInternalUse(tagName);

                  condition=new TagBinaryCondition(tagId,operatorEqual,valueValue);
                .)
                .
  NOTEQUALSCOND<const std::string& tagName,TagCondition*& condition>
              = (.
                  std::string valueValue;
                .)
                "!="
                string (. valueValue=Destring(t->val); .)
                (.
                  TagId tagId=config.RegisterTagForInternalUse(tagName);

                  condition=new TagBinaryCondition(tagId,operatorNotEqual,valueValue);
                .)
                .
  ISINCOND<const std::string& tagName,TagCondition*& condition>
              = (.
                 std::list<std::string> values;
                .)
                "IN"
                "["
                string   (. values.push_back(Destring(t->val)); .)
                {
                  ","
                  string (. values.push_back(Destring(t->val)); .)
                }
                "]"
                (.
                  TagId tagId=config.RegisterTagForInternalUse(tagName);

                  if (values.size()==1) {
                    condition=new TagBinaryCondition(tagId,operatorEqual,values.front());
                  }
                  else {
                    TagIsInCondition *isInCondition=new TagIsInCondition(tagId);

                    for (std::list<std::string>::const_iterator s=values.begin();
                         s!=values.end();
                         ++s) {
                      isInCondition->AddTagValue(*s);
                    }

                    condition=isInCondition;
                  }
                .)
                .
  EXISTSCOND<TagCondition*& condition>
              = "EXISTS"
                 string
                 (.
                   condition=new TagExistsCondition(config.RegisterTagForInternalUse(Destring(t->val)));
                 .)
                 .

  TYPEKINDS<unsigned char& types>
              = (.
                  types=0;
                .)

                TYPEKIND<types>

                {
                  [
                    ","
                  ]
                  TYPEKIND<types>
                }
                .

  TYPEKIND<unsigned char& types>
              =  "NODE"      (. types|=TypeInfo::typeNode; .)
               | "WAY"       (. types|=TypeInfo::typeWay; .)
               | "AREA"      (. types|=TypeInfo::typeArea; .)
               | "RELATION"  (. types|=TypeInfo::typeRelation; .)
               .

  TYPEOPTIONS<TypeInfo& typeInfo>
              = TYPEOPTION<typeInfo>
                {
                  TYPEOPTION<typeInfo>
                }
              .

  TYPEOPTION<TypeInfo& typeInfo>
              =  "ROUTE"             (. typeInfo.CanBeRoute(true); .)
               | "INDEX"             (. typeInfo.CanBeIndexed(true); .)
               | "CONSUME_CHILDREN"  (. typeInfo.SetConsumeChildren(true); .)
               | "OPTIMIZE_LOW_ZOOM" (. typeInfo.SetOptimizeLowZoom(true); .)
               | "IGNORE"            (. typeInfo.SetIgnore(true); .)
               | "MULTIPOLYGON"      (. typeInfo.SetMultipolygon(true); .)
               | "PIN_WAY"           (. typeInfo.SetPinWay(true); .)
               | "IGNORESEALAND"     (. typeInfo.SetIgnoreSeaLand(true); .)
               .

  IDENT<std::string& value>
              = ident
                (.
                  value=t->val;
                .)
                .
END OST.

