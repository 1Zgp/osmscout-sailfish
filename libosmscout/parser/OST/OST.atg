#include <cassert>
#include <iostream>

#include <osmscout/TypeConfig.h>
#include <osmscout/Util.h>

COMPILER OST

std::string Destring(const char* str)
{
  std::string result(str);

  if (result.length()>=2 &&
      result[0]=='"' &&
      result[result.length()-1]=='"') {
    result=result.substr(1,result.length()-2);
  }

  return result;
}

CHARACTERS
  letter     = 'a'..'z' + 'A'..'Z'.
  digit      = '0'..'9'.
  eol        = '\n'.
  stringchar = ANY - '"'.
  quotchar   = ANY.

TOKENS
  ident      = letter {letter | '_'}.
  number     = digit {digit}.
  string     = '"' {stringchar | '\\' quotchar} '"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO eol

IGNORE '\t' + '\r' + '\n'

PRODUCTIONS
  OST         = SYNC "OST" [TYPES] "END".
  TYPES       = SYNC "TYPES" TYPE {TYPE}.
  TYPE        = (.
                  Condition     *condition=NULL;
                  TypeInfo      typeInfo;
                  unsigned char types;
                .)
                SYNC "TYPE"
                string                         (. typeInfo.SetType(Destring(t->val)); .)

                "="
                TYPEKINDS<types>
                "(" CONDITION<condition> ")"   (. typeInfo.AddCondition(types,condition); .)

                {
                  "OR"
                  TYPEKINDS<types>
                  "(" CONDITION<condition> ")" (. typeInfo.AddCondition(types,condition); .)
                }

                [
                  "OPTIONS"
                  TYPEOPTIONS<typeInfo>
                ]

                (.
                  config.AddTypeInfo(typeInfo);
                .)
                .

  CONDITION<Condition*& condition>
              = (.
                  std::list<Condition*> conditions;
                  Condition             *subCond;
                .)
                ANDCOND<subCond>   (. conditions.push_back(subCond); .)
                {
                  "OR"
                  ANDCOND<subCond> (. conditions.push_back(subCond); .)
                }
                (.
                  if (conditions.size()==1) {
                    condition=conditions.front();
                  }
                  else {
                    OrCondition *orCondition=new OrCondition();

                    for (std::list<Condition*>::const_iterator c=conditions.begin();
                         c!=conditions.end();
                         ++c) {
                      orCondition->AddCondition(*c);
                    }

                    condition=orCondition;
                  }
                .)
                .
  ANDCOND<Condition*& condition>
              = (.
                  std::list<Condition*> conditions;
                  Condition             *subCond;
                .)
                BOOLCOND<subCond>     (. conditions.push_back(subCond); .)
                {
                  "AND"
                  BOOLCOND<subCond>   (. conditions.push_back(subCond); .)
                }
                (.
                  if (conditions.size()==1) {
                    condition=conditions.front();
                  }
                  else {
                    AndCondition *andCondition=new AndCondition();

                    for (std::list<Condition*>::const_iterator c=conditions.begin();
                         c!=conditions.end();
                         ++c) {
                      andCondition->AddCondition(*c);
                    }

                    condition=andCondition;
                  }
                .)
                .
  BOOLCOND<Condition*& condition>
              =   BINARYCOND<condition>
                | EXISTSCOND<condition>
                | "(" CONDITION<condition> ")"
                | "!" BOOLCOND<condition> (. condition=new NotCondition(condition); .)
                .

  BINARYCOND<Condition*& condition>
              = (.
                  std::string nameValue;
                .)
                string (. nameValue=Destring(t->val); .)
                (
                  EQUALSCOND<nameValue,condition>
                | NOTEQUALSCOND<nameValue,condition>
                | ISINCOND<nameValue,condition>
                )
                .

  EQUALSCOND<const std::string& tagName,Condition*& condition>
              = (.
                  std::string valueValue;
                .)
                "=="
                string (. valueValue=Destring(t->val); .)
                (.
                  TagId tagId=config.RegisterTagForInternalUse(tagName);

                  condition=new EqualsCondition(tagId,valueValue);
                .)
                .
  NOTEQUALSCOND<const std::string& tagName,Condition*& condition>
              = (.
                  std::string valueValue;
                .)
                "!="
                string (. valueValue=Destring(t->val); .)
                (.
                  TagId tagId=config.RegisterTagForInternalUse(tagName);

                  condition=new NotEqualsCondition(tagId,valueValue);
                .)
                .
  ISINCOND<const std::string& tagName,Condition*& condition>
              = (.
                 std::list<std::string> values;
                .)
                "IN"
                "["
                string   (. values.push_back(Destring(t->val)); .)
                {
                  ","
                  string (. values.push_back(Destring(t->val)); .)
                }
                "]"
                (.
                  TagId tagId=config.RegisterTagForInternalUse(tagName);

                  if (values.size()==1) {
                    condition=new EqualsCondition(tagId,values.front());
                  }
                  else {
                    IsInCondition *isInCondition=new IsInCondition(tagId);

                    for (std::list<std::string>::const_iterator s=values.begin();
                         s!=values.end();
                         ++s) {
                      isInCondition->AddTagValue(*s);
                    }

                    condition=isInCondition;
                  }
                .)
                .
  EXISTSCOND<Condition*& condition>
              = "EXISTS"
                 string
                 (.
                   condition=new ExistsCondition(config.RegisterTagForInternalUse(Destring(t->val)));
                 .)
                 .

  TYPEKINDS<unsigned char& types>
              = (.
                  types=0;
                .)

                TYPEKIND<types>

                {
                  [
                    ","
                  ]
                  TYPEKIND<types>
                }
                .

  TYPEKIND<unsigned char& types>
              =  "NODE"      (. types|=TypeInfo::typeNode; .)
               | "WAY"       (. types|=TypeInfo::typeWay; .)
               | "AREA"      (. types|=TypeInfo::typeArea; .)
               | "RELATION"  (. types|=TypeInfo::typeRelation; .)
               .

  TYPEOPTIONS<TypeInfo& typeInfo>
              = TYPEOPTION<typeInfo>
                {
                  TYPEOPTION<typeInfo>
                }
              .

  TYPEOPTION<TypeInfo& typeInfo>
              =  "ROUTE"            (. typeInfo.CanBeRoute(true); .)
               | "INDEX"            (. typeInfo.CanBeIndexed(true); .)
               | "CONSUME_CHILDREN" (. typeInfo.SetConsumeChildren(true); .)
               | "IGNORE"           (. typeInfo.SetIgnore(true); .)
               .

END OST.

